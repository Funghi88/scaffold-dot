/**
 * DON'T MODIFY OR DELETE THIS SCRIPT (unless you know what you're doing)
 *
 * This script generates the file containing the contracts Abi definitions.
 * These definitions are used to derive the types needed in the custom scaffold-eth hooks, for example.
 * This script should run as the last deploy script.
 */

import * as fs from "fs";
import prettier from "prettier";
import { HardhatRuntimeEnvironment } from "hardhat/types";

const generatedContractComment = `
/**
 * This file is autogenerated by Scaffold-ETH.
 * You should not edit it manually or your changes might be overwritten.
 */
`;

const DEPLOYMENTS_DIR = "./deployments";
// Try Foundry artifacts first, fallback to Hardhat artifacts
const FOUNDRY_ARTIFACTS_DIR = "./foundry/out";
const HARDHAT_ARTIFACTS_DIR = "./artifacts-pvm";
const ARTIFACTS_DIR = fs.existsSync(FOUNDRY_ARTIFACTS_DIR) ? FOUNDRY_ARTIFACTS_DIR : HARDHAT_ARTIFACTS_DIR;

function getDirectories(path: string) {
  return fs
    .readdirSync(path, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);
}

function getContractNames(path: string) {
  return fs
    .readdirSync(path, { withFileTypes: true })
    .filter(dirent => dirent.isFile() && dirent.name.endsWith(".json"))
    .map(dirent => dirent.name.split(".")[0]);
}

function getActualSourcesForContract(sources: Record<string, any>, contractName: string) {
  for (const sourcePath of Object.keys(sources)) {
    const sourceName = sourcePath.split("/").pop()?.split(".sol")[0];
    if (sourceName === contractName) {
      // Foundry metadata structure: sources[path] = { content: "..." }
      // Hardhat metadata structure: sources[path] = { content: "..." }
      const sourceData = sources[sourcePath];
      if (!sourceData || typeof sourceData !== 'object') {
        continue;
      }
      const contractContent = sourceData.content as string;
      if (!contractContent || typeof contractContent !== 'string') {
        continue;
      }
      const regex = /contract\s+(\w+)\s+is\s+([^{}]+)\{/;
      const match = contractContent.match(regex);

      if (match) {
        const inheritancePart = match[2];
        // Split the inherited contracts by commas to get the list of inherited contracts
        const inheritedContracts = inheritancePart.split(",").map(contract => `${contract.trim()}.sol`);

        return inheritedContracts;
      }
      return [];
    }
  }
  return [];
}

function getInheritedFunctions(sources: Record<string, any>, contractName: string) {
  const actualSources = getActualSourcesForContract(sources, contractName);
  const inheritedFunctions = {} as Record<string, any>;

  for (const sourceContractName of actualSources) {
    const sourcePath = Object.keys(sources).find(key => key.includes(`/${sourceContractName}`));
    if (sourcePath) {
      const sourceName = sourcePath?.split("/").pop()?.split(".sol")[0];
      const { abi } = JSON.parse(fs.readFileSync(`${ARTIFACTS_DIR}/${sourcePath}/${sourceName}.json`).toString());
      for (const functionAbi of abi) {
        if (functionAbi.type === "function") {
          inheritedFunctions[functionAbi.name] = sourcePath;
        }
      }
    }
  }

  return inheritedFunctions;
}

/**
 * Get all contract artifact names from a .sol file
 * Scans the artifacts directory (Foundry or Hardhat) and returns all contract names (excluding .dbg.json files)
 */
function getAllContractArtifactsFromSolFile(solFileName: string): string[] {
  // Foundry structure: foundry/out/contracts/ERC20.sol/ERC20Token.json
  // Hardhat structure: artifacts-pvm/contracts/ERC20.sol/ERC20Token.json
  const solDirPath = `${ARTIFACTS_DIR}/contracts/${solFileName}`;
  
  if (!fs.existsSync(solDirPath)) {
    // Try Foundry's alternative structure: foundry/out/ERC20.sol/ERC20Token.json
    const foundryAltPath = `${FOUNDRY_ARTIFACTS_DIR}/${solFileName}`;
    if (fs.existsSync(foundryAltPath)) {
      const files = fs.readdirSync(foundryAltPath, { withFileTypes: true });
      return files
        .filter(dirent => dirent.isFile() && dirent.name.endsWith('.json') && !dirent.name.endsWith('.dbg.json'))
        .map(dirent => dirent.name.replace('.json', ''));
    }
    console.warn(`Artifacts directory not found for ${solFileName}`);
    return [];
  }

  const files = fs.readdirSync(solDirPath, { withFileTypes: true });
  const contractNames = files
    .filter(dirent => dirent.isFile() && dirent.name.endsWith('.json') && !dirent.name.endsWith('.dbg.json'))
    .map(dirent => dirent.name.replace('.json', ''));

  return contractNames;
}

/**
 * Find the .sol file that contains a given contract by scanning artifacts
 * Checks both Foundry and Hardhat artifact locations
 */
function findSolFileForContract(contractName: string): string | null {
  // Try Foundry structure first: foundry/out/contracts/ERC20.sol/ERC20Token.json
  const foundryContractsDir = `${FOUNDRY_ARTIFACTS_DIR}/contracts`;
  if (fs.existsSync(foundryContractsDir)) {
    const solDirs = fs.readdirSync(foundryContractsDir, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory() && dirent.name.endsWith('.sol'))
      .map(dirent => dirent.name);

    for (const solDir of solDirs) {
      const artifactPath = `${foundryContractsDir}/${solDir}/${contractName}.json`;
      if (fs.existsSync(artifactPath)) {
        return solDir;
      }
    }
  }

  // Try Foundry alternative structure: foundry/out/ERC20.sol/ERC20Token.json
  if (fs.existsSync(FOUNDRY_ARTIFACTS_DIR)) {
    const solDirs = fs.readdirSync(FOUNDRY_ARTIFACTS_DIR, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory() && dirent.name.endsWith('.sol'))
      .map(dirent => dirent.name);

    for (const solDir of solDirs) {
      const artifactPath = `${FOUNDRY_ARTIFACTS_DIR}/${solDir}/${contractName}.json`;
      if (fs.existsSync(artifactPath)) {
        return solDir;
      }
    }
  }

  // Fallback to Hardhat structure: artifacts-pvm/contracts/ERC20.sol/ERC20Token.json
  const hardhatContractsDir = `${HARDHAT_ARTIFACTS_DIR}/contracts`;
  if (fs.existsSync(hardhatContractsDir)) {
    const solDirs = fs.readdirSync(hardhatContractsDir, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory() && dirent.name.endsWith('.sol'))
      .map(dirent => dirent.name);

    for (const solDir of solDirs) {
      const artifactPath = `${hardhatContractsDir}/${solDir}/${contractName}.json`;
      if (fs.existsSync(artifactPath)) {
        return solDir;
      }
    }
  }

  return null;
}

// Use either hardhat-deploy directory structure if it exists, or directly get contracts from artifacts
async function getContractDataFromDeployments(hre: HardhatRuntimeEnvironment, deployedContracts?: Record<string, string>, chainIdOverride?: string) {
  // If deployed contracts are provided, use them first (prioritize over deployments directory)
  if (deployedContracts && Object.keys(deployedContracts).length > 0) {
    console.log("üéØ Using provided deployed contract addresses...");
    
    // Get the network chainId - use override if provided, otherwise try to get from Hardhat
    let chainId: string;
    if (chainIdOverride) {
      chainId = chainIdOverride;
    } else {
      try {
        const network = await hre.network.provider.send('eth_chainId');
        chainId = parseInt(network, 16).toString();
      } catch (error) {
        // If we can't get chainId from Hardhat (e.g., when using ethers directly), use default
        console.warn("‚ö†Ô∏è  Could not get chainId from Hardhat network. Using default: 420420422 (Paseo)");
        chainId = "420420422"; // Default to Paseo testnet
      }
    }
    const contracts = {} as Record<string, any>;
    const processedSolFiles = new Set<string>(); // Track which .sol files we've already processed
    
    // For each deployed contract, get its ABI from artifacts AND all other contracts from the same .sol file
    for (const [contractName, contractAddress] of Object.entries(deployedContracts)) {
      console.log(`Processing contract: ${contractName} at ${contractAddress}`);
      
      // Find which .sol file this contract belongs to
      const solFile = findSolFileForContract(contractName);
      
      if (!solFile) {
        console.warn(`Could not find .sol file for contract ${contractName}`);
        continue;
      }
      
      // If we've already processed this .sol file, skip it (all artifacts from it are already added)
      if (processedSolFiles.has(solFile)) {
        console.log(`Skipping ${contractName} - already processed all contracts from ${solFile}`);
        continue;
      }
      
      // Mark this .sol file as processed
      processedSolFiles.add(solFile);
      
      // Get ALL contract artifacts from this .sol file (for logging)
      const allArtifacts = getAllContractArtifactsFromSolFile(solFile);
      console.log(`Found ${allArtifacts.length} artifacts in ${solFile}: ${allArtifacts.join(', ')}`);
      
      // IMPORTANT: Only add the artifact that matches the deployed contract name
      // We only deployed the contract specified in contractName, not all contracts from the .sol file
      // Try multiple possible paths for Foundry artifacts
      let artifactPath = `${FOUNDRY_ARTIFACTS_DIR}/contracts/${solFile}/${contractName}.json`;
      if (!fs.existsSync(artifactPath)) {
        artifactPath = `${FOUNDRY_ARTIFACTS_DIR}/${solFile}/${contractName}.json`;
      }
      if (!fs.existsSync(artifactPath)) {
        artifactPath = `${HARDHAT_ARTIFACTS_DIR}/contracts/${solFile}/${contractName}.json`;
      }
      
      if (!fs.existsSync(artifactPath)) {
        console.warn(`‚ö†Ô∏è  Artifact not found for deployed contract "${contractName}"`);
        console.warn(`   Tried: ${FOUNDRY_ARTIFACTS_DIR}/contracts/${solFile}/${contractName}.json`);
        console.warn(`   Tried: ${FOUNDRY_ARTIFACTS_DIR}/${solFile}/${contractName}.json`);
        console.warn(`   Tried: ${HARDHAT_ARTIFACTS_DIR}/contracts/${solFile}/${contractName}.json`);
        console.warn(`   Available artifacts in ${solFile}: ${allArtifacts.join(', ')}`);
        continue;
      }
      
      const artifactContent = JSON.parse(fs.readFileSync(artifactPath).toString());
      const { abi } = artifactContent;
      // Foundry artifacts may have metadata as a string or object, or may not have it at all
      let metadata = artifactContent.metadata;
      if (typeof metadata === 'string') {
        try {
          metadata = JSON.parse(metadata);
        } catch (e) {
          // If metadata is not valid JSON, set to null
          metadata = null;
        }
      }
      const inheritedFunctions = metadata && metadata.sources ? getInheritedFunctions(metadata.sources, contractName) : {};
      
      contracts[contractName] = { 
        address: contractAddress, 
        abi, 
        inheritedFunctions 
      };
      
      console.log(`‚úÖ Added ${contractName} with address ${contractAddress}`);
    }
    
    return { [chainId]: contracts };
  }
  
  // If deployments directory exists, use it (hardhat-deploy style)
  if (fs.existsSync(DEPLOYMENTS_DIR)) {
    console.log("üìÅ Found deployments directory, reading from hardhat-deploy files...");
    const output = {} as Record<string, any>;
    for (const chainName of getDirectories(DEPLOYMENTS_DIR)) {
      const chainId = fs.readFileSync(`${DEPLOYMENTS_DIR}/${chainName}/.chainId`).toString();
      const contracts = {} as Record<string, any>;
      for (const contractName of getContractNames(`${DEPLOYMENTS_DIR}/${chainName}`)) {
        const { abi, address, metadata }= JSON.parse(
          JSON.stringify(
            fs.readFileSync(`${DEPLOYMENTS_DIR}/${chainName}/${contractName}.json`),
          ),
        );
        const inheritedFunctions = metadata ? getInheritedFunctions(JSON.parse(metadata).sources, contractName) : {};
        contracts[contractName] = { address, abi, inheritedFunctions };
      }
      output[chainId] = contracts;
    }
    return output;
  } 
  // Otherwise, create empty contracts
  else {
    console.warn("No deployed contracts provided and no deployments directory found.");
    console.warn("Creating empty deployedContracts.ts file.");
    return {};
  }
}

/**
 * Generates the TypeScript contract definition file based on the json output of the contract deployment scripts
 * This script should be run last.
 */
const generateTsAbis = async function (hre: HardhatRuntimeEnvironment, deployedContracts?: Record<string, string>, chainIdOverride?: string) {
  const TARGET_DIR = "../nextjs/contracts/";
  const allContractsData = await getContractDataFromDeployments(hre, deployedContracts, chainIdOverride);

  const fileContent = Object.entries(allContractsData).reduce((content, [chainId, chainConfig]) => {
    return `${content}${parseInt(chainId).toFixed(0)}:${JSON.stringify(chainConfig, null, 2)},`;
  }, "");

  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR);
  }
  fs.writeFileSync(
    `${TARGET_DIR}deployedContracts.ts`,
    await prettier.format(
      `${generatedContractComment} import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract"; \n\n
 const deployedContracts = {${fileContent}} as const; \n\n export default deployedContracts satisfies GenericContractsDeclaration`,
      {
        parser: "typescript",
      },
    ),
  );

  console.log(`üìù Updated TypeScript contract definition file on ${TARGET_DIR}deployedContracts.ts`);
};

export default generateTsAbis;
export { getAllContractArtifactsFromSolFile };
